pt_df <- tibble::tibble(pID=new_pID,rate=q,diam=point$diam,x0=x1,y0=y1,
origin=point$origin,transform=boundary$bound_type,source_bound=boundary$bID,path=path)
if (max(grepl("sf",class(point)))) {
pt_df <- pt_df %>% dplyr::mutate(X=x1,Y=y1) %>%
sf::st_as_sf(coords=c("X","Y")) %>% sf::st_set_crs(sf::st_crs(point))
}
return(pt_df)
}
get_mirror_point(point_sf, boundary, new_pID=2)
expect_equal(get_mirror_point(point, boundary, new_pID=2),
tibble::tibble(pID=2,rate=0.5,diam=0.75,x0=1,y0=1,origin=1,transform="NF",
source_bound=1,path="1 : 1 (1-NF)"))
get_mirror_point(point, boundary, new_pID=2)
class(get_mirror_point(point_sf, boundary, new_pID=2))
names(wells)
get_mirror_point(point, boundary, new_pID=2)
devtools::document()
?generate_image_wells
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
bounds <- data.frame(m=c(1,-1),b=(0.5,1),bound_type=c("CH","NF"))
data.frame(m=c(1,-1),b=(0.5,1),bound_type=c("CH","NF"))
data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
devtools::document()
?generate_image_wells
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
generate_image_wells(wells,bounds,num_levels=1)
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,bounds,num_levels=1)
generate_image_wells(wells,bounds,num_levels=1)
wells_full[[i]]$pID
wells_full
wells_full[[i]]$pID
c(wells_full[[i]]$pID,new_wells$pID)
new_wells$pID
wells_full[[i]]
wells_full[[i]] %>% filter(FALSE)
wells_full[[i]] %>% dplyr::filter(FALSE)
#' The function requires that the wells are labeled with a column of identifiers, pID. Similarly,
#' it requires that bounds have identifiers, bID. If either/both of these columns are not
#' present, the function generates them. The image well pID's are always generated automatically.
#' not present
#' @importFrom magrittr %>%
#' @examples
#' wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
#' bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
#' generate_image_wells(wells,bounds,num_levels=1)
#' generate_image_wells(wells,bounds,num_levels=2)
generate_image_wells <- function(wells,bounds,num_levels) {
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
if (!max(grepl("^bID$",names(bounds)))) { # generate pID's if they are not present
bounds <- bounds %>% dplyr::mutate(bID=dplyr::row_number())
}
wells <- wells %>% dplyr::mutate(path=pID,transform="none",source_bound="none",path="x")
wells_full <- list(wells)
for (i in 1:(num_levels-1)) { # for each level, generate mirrored points in next level
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
for (j in 1:dim(wells_full[[i]])[1]) { # for each well in level i
point <- wells_full[[i]][j,] # get point in level i
for (k in 1:dim(bounds)[1]) { # for each boundary
boundary <- bounds[k,] # get boundary
if (point$source_bound!=boundary$bID) { # only take mirror for boundaries that are not the source boundary
new_pID <- max(c(wells_full[[i]]$pID,new_wells$pID)) + 1 # get new point id
new_point <- get_mirror_point(point,boundary,new_pID) # get new point
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
}
}
}
wells_full[[i+1]] <- new_wells
}
wells <- do.call(rbind,wells_full) %>%
mutate(level=as.factor(stringr::str_count(path,":")))
return(wells)
}
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,bounds,num_levels=1)
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,bounds,num_levels=1)
new_wells
source('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,bounds,num_levels=1)
generate_image_wells(wells,bounds,num_levels=1)
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,bounds,num_levels=1)
wells_full[[i]]
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,bounds,num_levels=1)
wells_full
wells_full[[i]]
i
num_levels
#' The function requires that the wells are labeled with a column of identifiers, pID. Similarly,
#' it requires that bounds have identifiers, bID. If either/both of these columns are not
#' present, the function generates them. The image well pID's are always generated automatically.
#' not present
#' @importFrom magrittr %>%
#' @examples
#' wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
#' bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
#' generate_image_wells(wells,bounds,num_levels=1)
#' generate_image_wells(wells,bounds,num_levels=2)
generate_image_wells <- function(wells,bounds,num_levels) {
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
if (!max(grepl("^bID$",names(bounds)))) { # generate pID's if they are not present
bounds <- bounds %>% dplyr::mutate(bID=dplyr::row_number())
}
wells <- wells %>% dplyr::mutate(path=pID,origin=pID,transform="none",source_bound="none",path="x")
wells_full <- list(wells)
for (i in 1:num_levels) { # for each level, generate mirrored points in next level
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
for (j in 1:dim(wells_full[[i]])[1]) { # for each well in level i
point <- wells_full[[i]][j,] # get point in level i
for (k in 1:dim(bounds)[1]) { # for each boundary
boundary <- bounds[k,] # get boundary
if (point$source_bound!=boundary$bID) { # only take mirror for boundaries that are not the source boundary
new_pID <- max(c(wells_full[[i]]$pID,new_wells$pID)) + 1 # get new point id
new_point <- get_mirror_point(point,boundary,new_pID) # get new point
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
}
}
}
wells_full[[i+1]] <- new_wells
}
wells <- do.call(rbind,wells_full) %>%
mutate(level=as.factor(stringr::str_count(path,":")))
return(wells)
}
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
#' The function requires that the wells are labeled with a column of identifiers, pID. Similarly,
#' it requires that bounds have identifiers, bID. If either/both of these columns are not
#' present, the function generates them. The image well pID's are always generated automatically.
#' not present
#' @importFrom magrittr %>%
#' @examples
#' wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
#' bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
#' generate_image_wells(wells,bounds,num_levels=1)
#' generate_image_wells(wells,bounds,num_levels=2)
generate_image_wells <- function(wells,bounds,num_levels) {
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
if (!max(grepl("^bID$",names(bounds)))) { # generate pID's if they are not present
bounds <- bounds %>% dplyr::mutate(bID=dplyr::row_number())
}
wells <- wells %>% dplyr::mutate(path=pID,origin=pID,transform="none",source_bound="none",path="x")
wells_full <- list(wells)
for (i in 1:num_levels) { # for each level, generate mirrored points in next level
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
for (j in 1:dim(wells_full[[i]])[1]) { # for each well in level i
point <- wells_full[[i]][j,] # get point in level i
for (k in 1:dim(bounds)[1]) { # for each boundary
boundary <- bounds[k,] # get boundary
if (point$source_bound!=boundary$bID) { # only take mirror for boundaries that are not the source boundary
new_pID <- max(c(wells_full[[i]]$pID,new_wells$pID)) + 1 # get new point id
new_point <- get_mirror_point(point,boundary,new_pID) # get new point
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
}
}
}
wells_full[[i+1]] <- new_wells
}
wells <- do.call(rbind,wells_full) %>%
mutate(level=as.factor(stringr::str_count(path,":")))
return(wells)
}
generate_image_wells(wells,bounds,num_levels=1)
#' The function requires that the wells are labeled with a column of identifiers, pID. Similarly,
#' it requires that bounds have identifiers, bID. If either/both of these columns are not
#' present, the function generates them. The image well pID's are always generated automatically.
#' not present
#' @importFrom magrittr %>%
#' @examples
#' wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
#' bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
#' generate_image_wells(wells,bounds,num_levels=1)
#' generate_image_wells(wells,bounds,num_levels=2)
generate_image_wells <- function(wells,bounds,num_levels) {
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
if (!max(grepl("^bID$",names(bounds)))) { # generate pID's if they are not present
bounds <- bounds %>% dplyr::mutate(bID=dplyr::row_number())
}
wells <- wells %>% dplyr::mutate(path=pID,origin=pID,transform="none",source_bound="none",path="x")
wells_full <- list(wells)
for (i in 1:num_levels) { # for each level, generate mirrored points in next level
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
for (j in 1:dim(wells_full[[i]])[1]) { # for each well in level i
point <- wells_full[[i]][j,] # get point in level i
for (k in 1:dim(bounds)[1]) { # for each boundary
boundary <- bounds[k,] # get boundary
if (point$source_bound!=boundary$bID) { # only take mirror for boundaries that are not the source boundary
new_pID <- max(c(wells_full[[i]]$pID,new_wells$pID)) + 1 # get new point id
new_point <- get_mirror_point(point,boundary,new_pID) # get new point
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
}
}
}
wells_full[[i+1]] <- new_wells
}
wells <- do.call(rbind,wells_full) %>%
dplyr::mutate(level=as.factor(stringr::str_count(path,":")))
return(wells)
}
generate_image_wells(wells,bounds,num_levels=1)
devtools::document()
?generate_image_wells
pts_utm
wells <- prep_wells_sf(pts_utm)
devtools::load_all()
wells <- prep_wells_sf(pts_utm)
wells
boundaries <- get_slope(boundaries_utm)
devtools::load_all()
devtools::document()
?get_slope
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
devtools::load_all()
(wells,boundaries,num_levels=2)
wells
boundaries
boundaries <- get_slope(boundaries_utm)
boundaries
generate_image_wells(wells,bounds,num_levels=1)
?generate_image_wells
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
generate_image_wells(wells,bounds,num_levels=1)
wells
bounds
devtools::load_all()
devtools::load_all()
devtools::load_all()
well_images <- generate_image_wells(wells,boundaries,num_levels=2)
well_images
devtools::load_all()
boundaries <- prep_bounds(boundaries_utm)
boundaries
devtools::load_all()
boundaries <- prep_bounds(boundaries_utm)
boundaries
devtools::load_all()
boundaries <- prep_bounds(boundaries_utm)
boundaries
boundaries <- prep_bounds(boundaries_utm)
boundaries
devtools::load_all()
boundaries <- prep_bounds(boundaries_utm)
boundaries
boundaries <- prep_bounds(boundaries_utm)
boundaries
well_images <- generate_image_wells(wells,boundaries,num_levels=2)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
devtools::load_all()
# install.packages(".", repos = NULL, type="source")
# library(anema)
library(magrittr)
library(ggplot2)
pts_wgs <- sf::read_sf("../../../genevois/spatial/shp/manual/pts_text.shp")
pts_wgs
boundaries_wgs <- sf::read_sf("../../../genevois/spatial/shp/manual/lines_text.shp")
boundaries_wgs
utm_zone <- longitude_to_utm_zone(6.2)
utm_proj4 <- utm_zone_to_proj4(utm_zone)
pts_utm <- pts_wgs %>% sf::st_transform(utm_proj4)
boundaries_utm <- boundaries_wgs %>% sf::st_transform(utm_proj4)
ggplot() +
geom_sf(data=boundaries_utm, aes()) +
geom_sf(data=pts_utm, aes())
wells <- prep_wells_sf(pts_utm)
boundaries <- prep_bounds(boundaries_utm)
well_images <- generate_image_wells(wells,boundaries,num_levels=2)
devtools::document()
?generate_image_wells
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8),bID=c(1,2))
bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
generate_image_wells(wells,bounds,num_levels=1)
wells
bounds
generate_image_wells(wells,bounds,num_levels=1)
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
i
1 + 1
#' @section Notes:
#' The function requires that the wells are labeled with a column of identifiers, pID. If it is not
#' present, the function generates them. The image well pID's are always generated automatically.
#' not present.
#' @importFrom magrittr %>%
#' @examples
#' wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8),bID=c(1,2))
#' bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
#' generate_image_wells(wells,bounds,num_levels=1)
#' generate_image_wells(wells,bounds,num_levels=2)
generate_image_wells <- function(wells,bounds,num_levels) {
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
wells <- wells %>% dplyr::mutate(path=pID,origin=pID,transform="none",source_bound="none",path="x")
wells_full <- list(wells)
for (i in 1:num_levels) { # for each level, generate mirrored points in next level
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
for (j in 1:dim(wells_full[[i]])[1]) { # for each well in level i
point <- wells_full[[i]][j,] # get point in level i
for (k in 1:dim(bounds)[1]) { # for each boundary
boundary <- bounds[k,] # get boundary
if (point$source_bound!=boundary$bID) { # only take mirror for boundaries that are not the source boundary
new_pID <- max(c(wells_full[[i]]$pID,new_wells$pID)) + 1 # get new point id
new_point <- get_mirror_point(point,boundary,new_pID) # get new point
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
}
}
}
wells_full[[i+1]] <- new_wells
}
wells <- do.call(rbind,wells_full) %>%
dplyr::mutate(level=as.factor(stringr::str_count(path,":")))
return(wells)
}
generate_image_wells(wells,bounds,num_levels=1)
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8),bID=c(1,2))
bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
generate_image_wells(wells,bounds,num_levels=1)
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8),bID=c(1,2))
bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"))
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
wells
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"),bID=c(1,2))
generate_image_wells(wells,bounds,num_levels=1)
devtools::document()
?generate_well_images
devtools::load_all()
?generate_well_images
?generate_image_wells
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"),bID=c(1,2))
generate_image_wells(wells,bounds,num_levels=1)
generate_image_wells(wells,bounds,num_levels=2)
dim(generate_image_wells(wells,bounds,num_levels=1))
class(generate_image_wells(wells,wells_sf,num_levels=1))
class(generate_image_wells(wells_sf,bounds,num_levels=1))
wells_sf
wells_sf
wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
wells_sf <- wells %>% dplyr::mutate(X=x0,Y=y0) %>% sf::st_as_sf(coords=c("X","Y"))
class(generate_image_wells(wells_sf,bounds,num_levels=1))
wells <- tibble::tibble(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
wells_sf <- wells %>% dplyr::mutate(X=x0,Y=y0) %>% sf::st_as_sf(coords=c("X","Y"))
bounds <- tibble::tibble(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"),bID=c(1,2))
class(generate_image_wells(wells_sf,bounds,num_levels=1))
well_images <- generate_image_wells(wells,boundaries,num_levels=2)
wells <- prep_wells_sf(pts_utm)
boundaries <- prep_bounds(boundaries_utm)
well_images <- generate_image_wells(wells,boundaries,num_levels=2)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
devtools::load_all()
# install.packages(".", repos = NULL, type="source")
# library(anema)
library(magrittr)
library(ggplot2)
pts_wgs <- sf::read_sf("../../../genevois/spatial/shp/manual/pts_text.shp")
pts_wgs
boundaries_wgs <- sf::read_sf("../../../genevois/spatial/shp/manual/lines_text.shp")
boundaries_wgs
utm_zone <- longitude_to_utm_zone(6.2)
utm_proj4 <- utm_zone_to_proj4(utm_zone)
pts_utm <- pts_wgs %>% sf::st_transform(utm_proj4)
boundaries_utm <- boundaries_wgs %>% sf::st_transform(utm_proj4)
ggplot() +
geom_sf(data=boundaries_utm, aes()) +
geom_sf(data=pts_utm, aes())
wells <- prep_wells_sf(pts_utm)
boundaries <- prep_bounds(boundaries_utm)
boundaries
wells
boundaries
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
source('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,boundaries,num_levels=2)
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
new_wells
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,boundaries,num_levels=2)
new_wells
wells_full[[i+1]] <- new_wells
j
i
i
wells_full[[i+1]] <- new_wells
generate_image_wells(wells,boundaries,num_levels=2)
wells_full
well_cols
well_cols <- names(wells)
wells
well_cols
well_cols[!(well_cols %in% names(new_wells))]
new_wells
wells_full <- list(wells)
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
new_wells
wells_full <- list(wells)
wells_full
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
i <- 1
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
new_wells
new_wells
well_cols[!(well_cols %in% names(new_wells))]
names(new_wells)
well_cols %in% names(new_wells)
well_cols
names(new_wells)
#' @section Notes:
#' The function requires that the wells are labeled with a column of identifiers, pID. If it is not
#' present, the function generates them. The image well pID's are always generated automatically.
#' not present.
#' @importFrom magrittr %>%
#' @examples
#' wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
#' bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"),bID=c(1,2))
#' generate_image_wells(wells,bounds,num_levels=1)
#' generate_image_wells(wells,bounds,num_levels=2)
generate_image_wells <- function(wells,bounds,num_levels) {
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
wells <- wells %>% dplyr::mutate(path=pID,origin=pID,transform="none",source_bound="none",path="x")
well_cols <- names(wells)
wells_full <- list(wells)
for (i in 1:num_levels) { # for each level, generate mirrored points in next level
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
for (j in 1:dim(wells_full[[i]])[1]) { # for each well in level i
point <- wells_full[[i]][j,] # get point in level i
for (k in 1:dim(bounds)[1]) { # for each boundary
boundary <- bounds[k,] # get boundary
if (point$source_bound!=boundary$bID) { # only take mirror for boundaries that are not the source boundary
new_pID <- max(c(wells_full[[i]]$pID,new_wells$pID)) + 1 # get new point id
new_point <- get_mirror_point(point,boundary,new_pID) # get new point
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
new_wells[,well_cols[!(well_cols %in% names(new_wells))]] <- NA
}
}
}
wells_full[[i+1]] <- new_wells
}
wells <- do.call(rbind,wells_full) %>%
dplyr::mutate(level=as.factor(stringr::str_count(path,":")))
return(wells)
}
generate_image_wells(wells,boundaries,num_levels=2)
debugSource('~/Projects/CNH/packages/anema/R/anema_imaging.R')
generate_image_wells(wells,boundaries,num_levels=2)
#' @section Notes:
#' The function requires that the wells are labeled with a column of identifiers, pID. If it is not
#' present, the function generates them. The image well pID's are always generated automatically.
#' not present.
#' @importFrom magrittr %>%
#' @examples
#' wells <- data.frame(x0=c(0,0.5),y0=c(0,0.25),rate=c(0.5,-0.2),diam=c(0.75,0.8))
#' bounds <- data.frame(m=c(1,-1),b=c(0.5,1),bound_type=c("CH","NF"),bID=c(1,2))
#' generate_image_wells(wells,bounds,num_levels=1)
#' generate_image_wells(wells,bounds,num_levels=2)
generate_image_wells <- function(wells,bounds,num_levels) {
if (!max(grepl("^pID$",names(wells)))) { # generate pID's if they are not present
wells <- wells %>% dplyr::mutate(pID=dplyr::row_number())
}
wells <- wells %>% dplyr::mutate(path=pID,origin=pID,transform="none",source_bound="none",path="x")
well_cols <- names(wells)
wells_full <- list(wells)
for (i in 1:num_levels) { # for each level, generate mirrored points in next level
new_wells <- wells_full[[i]] %>% dplyr::filter(FALSE)
for (j in 1:dim(wells_full[[i]])[1]) { # for each well in level i
point <- wells_full[[i]][j,] # get point in level i
for (k in 1:dim(bounds)[1]) { # for each boundary
boundary <- bounds[k,] # get boundary
if (point$source_bound!=boundary$bID) { # only take mirror for boundaries that are not the source boundary
new_pID <- max(c(wells_full[[i]]$pID,new_wells$pID)) + 1 # get new point id
new_point <- get_mirror_point(point,boundary,new_pID) # get new point
new_wells <- new_wells %>% rbind(new_point) # add point to new_wells
}
}
}
new_wells[,well_cols[!(well_cols %in% names(new_wells))]] <- NA
wells_full[[i+1]] <- new_wells
}
wells <- do.call(rbind,wells_full) %>%
dplyr::mutate(level=as.factor(stringr::str_count(path,":")))
return(wells)
}
generate_image_wells(wells,boundaries,num_levels=2)
generate_image_wells(wells,boundaries,num_levels=2)
well_images
wells
boundaries
