---
title: "anem-publication"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{anem-publication}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=4, 
  fig.height=2.5
)
```


### Abstract 

Numerous tools exist for simulating groundwater flow via finite element models (e.g., MODFLOW) or analytic element models (e.g., gflow).
These tools allow for analysis of complex groundwater behavior, but such functionality that may not be necessary projects that demand simple groundwater models combined with (1) ease of use or (2) advanced statistical or theoretical analysis.
We address each of these needs through the development of a web application and an R package that simulate 2-dimensional, steady-state groundwater flow in confined and unconfined aquifers with rectangular boundaries using analytic elements and the method of well images.
Both tools can be used independent of the computer platform, and offer functionality for defining aquifers and pumping wells, determining hydraulic head and lateral flow, calculating drawdown relationships among groups of wells, and estimating travel times for particles.
The ease of use of the web application should be especially valuabe in low-budget applications, such as small water management agencies or educational settings.
Integration of groundwater models with R can provide numerous benefits for quickly simulating and analyzing groundwater hydrology problems.
Such simulation can serve as a precursor to more complex groundwater modeling, or be used to simulate synthetic scenarios as a way to explore variability and uncertainty.
Because R is a functional programming language, the outputs from this package can be easily analyzed, mapped, and incorporated into more complex models in R.
Indeed, the linear behavior of groundwater flow and principle of superposition means that physically plausible groundwater dynamics can be incorporated into more complex models of hydrology and coupled human-natural systems.
We validate the code and describe multiple scenarios in which the web application and R package might be used.

## Outline

**Introduction**

Groundwater modeling background:

1. needs
1. existing tools
    * MODFLOW
    * gflow
    * Bakker python packages
    * other software packages
1. motivation for this package
    * ease of use
    * integration with R, data analytics
    * precursor to more complex groundwater models
    * component of more complex hydrological models or coupled models
    
    
**Theoretical background**

1. groundwater theory
    * flow equations
    * principle of superposition
    * confined and unconfined flow
    
**Web application**

1. Interface
    * Overview -- map-based interactive tool. Leaflet & open street map to immediately access basemaps. This interface is useful to seamlessly connect model results with physical setting.
    * Prepare scenario & view results tabs
1. Prepare scenario
1. View results

**Package description**

Basic functionality of the package

1. defining wells and aquifers in `anem`
1. generating drawdown relationships

**Validation**

Validation of the package

1. hydraulic head in a confined aquifer
2. discharge potential in an unconfined aquifer
3. flow direction
4. behavior along boundaries

**Use cases**

1. Pumping tests?
1. Well placement? (ie., drawdown relationships for wells at the boundary vs center of the aquifer?)
1. Game theory?
1. Dynamical systems?


## Introduction

Groundwater modeling is essential in a variety of applications in industry, academia, and resources management. Many tools exist to simulate groundwater behavior, including numerical solutions and analytical solutions. Rapid increases in computer processing mean that numerical approaches to groundwater modeling have become widely accepted and implemented. However, analytical approach to groundwater modeling still have value. Faster processing, multiple platforms exist in addition to computing platforms timml (Bakker). GUIs exist for specific platforms, such as windows. However, these tools are not cross-platform. One exception is the python package by Bakker. 

Make groundwater modeling more readily accessible for simple scenarios.

This package was created to evaluate the hydraulic relationships among wells, in order to estimate the effect of a group of wells on drawdown at these wells or other wells. It it based on method of images from the analytical element modeling approach, in which the 2-dimensional characteristics of aquifers are reproduced by strategically placing wells within the domain.

This package models *simple* aquifer and well configurations. The boundaries of the aquifer can be specified as *no flow* or *constant head* boundaries, and the corners of the aquifer must be right angles. For fully bounded aquifers, this means that the aquifer must be a rectangle. The constant head boundaries take the head of the undisturbed aquifer, h0.

Units are designed for length dimensions given in meters (or m^2^), and time in seconds

As you will see in this vignette, the package has a number of functions that are used to set up the aquifer boundaries and wells. For practical purposes, the package was designed for simple but real aquifers, and wells and boundaries of the aquifers can be imported as shapefiles and then prepared. 

## Theoretical background

### Analytic elements

The analytic element method represents the aquifer domain as the sum of analytical solutions of multiple elements added to the aquifer. 

**Pumping from a single well**

We assume that all flow within the aquifer follows the Depuit-Forschheimer assumption such that all flow is 2-Dimensional and parallel to the aquifer bottom, which is horizontal. Flow is governed by Darcy's law which, in the case of radial flow to a well, can be integrated to obtain the Thiem solution describing steady state hydraulic head and flow in the vicinity ($r<R$) of a pumping well:

\begin{align}
h - h_0 = -\frac{Q}{2 \pi T} \log \left( \frac{r}{R} \right)
\label{eq:thiemunconfined}
\end{align}

where $h$ is hydraulic head at a distance $r$ from a fully penetrating well that pumps at rate $Q$ (positive for injection, negative for abstraction), $h_0$ is the undisturbed hydraulic head when $Q=0$, $T$ is the transmissivity of the confined aquifer defined as saturated hydraulic conductivity multiplied by the thickness of the aquifer ($T= K_{sat} z_0$), and $R$ is the radius of influence of the pumping well, outside of which the hydraulic head is undisturbed by pumping ($h=h_0$). This solution is valid for steady state flow in confined aquifers.

The solution can also be written for unconfined aquifers in terms of *discharge potential*, $\phi$:
$$\phi - \phi_0 = -\frac{Q}{\pi K_{sat}} \log \left( \frac{r}{R} \right),$$
where discharge potential is defined as $\phi=h^2$, and $\phi_0$ is the undisturbed discharge potential when $Q=0$.

**Method of images**

In the method of images, wells are mirrored across aquifer boundaries to reproduce the characterics of the boundary, no flow or constant head.

```{r echo=FALSE, message=FALSE,warning=FALSE}
library(tidyverse)
library(sf)
# devtools::install_github("https://github.com/gopalpenny/anem")
# devtools::load_all("~/Projects/R_packages/anem")
library(anem)
```

```{r echo=FALSE, message=FALSE,warning=FALSE,fig.width=5.5,fig.height=3,cache=TRUE}
# Create a grid of locations
loc <- crossing(x=seq(-200,200,length.out=201),y=seq(-200,200,length.out=201))

# Constant head boundary
wells_constant_head <- define_wells(x=c(-100,100),y=c(-0,0),Q=c(1e-2,-1e-2),diam=c(0.1,0.1),R=c(500,500))
aquifer <- define_aquifer("confined",1e-4,z0=20,h0=0)
constant_head_boundary <- loc %>%
  dplyr::bind_cols(streamfunction=get_stream_function(loc,wells_constant_head,aquifer)) %>%
  dplyr::bind_cols(head=get_hydraulic_head(loc,wells_constant_head,aquifer))

# No flow boundary
wells_no_flow <- define_wells(x=c(-100,100),y=c(-0,0),Q=c(-1e-2,-1e-2),diam=c(0.1,0.1),R=c(500,500))
no_flow_boundary <- loc %>%
  dplyr::bind_cols(streamfunction=get_stream_function(loc,wells_no_flow,aquifer)) %>%
  dplyr::bind_cols(head=get_hydraulic_head(loc,wells_no_flow,aquifer))

thm <- theme(axis.text=element_blank(),axis.title=element_blank(),axis.ticks=element_blank(),
             panel.background = element_rect(fill=NA,color="black"),
             panel.border = element_rect(fill=NA,color="black"),
             plot.title = element_text(size=10))

p_CH <- ggplot() +
  geom_contour(data=constant_head_boundary,aes(x,y,z=head),bins=50,linetype="dashed",color="black") +
  geom_contour(data=constant_head_boundary,aes(x,y,z=streamfunction),bins=25,color="darkblue") +
  geom_point(data=wells_constant_head,aes(x,y,fill=well_type),size=3,shape=21) +
  theme(legend.position=c(0.8,0.15),legend.title=element_blank()) +
  coord_equal() + thm + ggtitle("Constant head boundary at x = 0")
p_NF <- ggplot() +
  geom_contour(data=no_flow_boundary,aes(x,y,z=head),bins=25,linetype="dashed",color="black") +
  geom_contour(data=no_flow_boundary,aes(x,y,z=streamfunction),bins=50,color="darkblue") +
  geom_point(data=wells_no_flow,aes(x,y,fill=well_type),size=3,shape=21) +
  theme(legend.position=c(0.8,0.1),legend.title=element_blank()) +
  coord_equal() + thm + ggtitle("No flow boundary at x = 0")
gridExtra::grid.arrange(p_CH,p_NF,nrow=1)
```


## Web application

## R package

### A simple example of drawdown relationships

Load packages for the vignette

```{r setup, eval=FALSE}
library(tidyverse)
library(sf)
# devtools::install_github("https://github.com/gopalpenny/anem")
# devtools::load_all("~/Projects/R_packages/anem")
library(anem)
```

Aquifers in this package are characterized by:

* Aquifer type, confined or unconfined
* Saturated hydraulic conductivity, Ksat
* Resting hydraulic head, h0
* Thickness of the aquifer, z0 (confined aquifers only)
* Aquifer boundaries, characterized by:
  + Boundary ID, or bID
  + Coordinates in a cartesian plane, given as slope, m, and intercept, b, and coordinates (x1, y1, x2, y2)
  + Boundary type, NF or CH
* Additional user-defined parameters

Use the `define_aquifer()` function to create a new aquifer, which has the class `aquifer`. This class is essentially a list with names parameters and a separate print method.

```{r cache=TRUE}
# define aquifer
bounds_df <- data.frame(bound_type=c("CH","NF","NF","NF"),m=c(Inf,0,Inf,0),b=c(0,1000,1000,0))
aquifer_unconfined <- define_aquifer("unconfined",1e-3,bounds=bounds_df,h0=100)
```

Wells are characterized by:

* Well ID, or wID
* Location x, y
* Pumping rate (+ for injection, - for pumping), Q
* Radius of influence, R
* Diameter, diam
* Well images (which are noted in the `well_image` column)
* Additional user-defined columns, including groups or weights.

The code below Defines 8 pumping wells using random locations and arbitrarily divides wells into countries "A" and "B" using a threshold at y = 500 m. The `define_wells()` function ensures that the wells have all appropriate columns, and the class of the returned object is a `tibble` (which functions like a `data.frame`, but has a couple bells and whistles). Also note that the radius of influence (R) is defined arbitrarily, but there is also a function to calculate this manually -- see `?get_ROI` for more details.

The `generate_image_wells()` function generates well images to recreate the bounderies defined by the aquifer, `aquifer_unconfined`.

```{r set_simple_aquifer,cache=TRUE}
# define wells and well images
set.seed(15)
wells_actual <- define_wells(x = runif(8,0,1000),
                             y = c(runif(4,0,500),runif(4,500,1000)),
                             Q = -1/4,
                             diam = 1,
                             R = 1000,
                             weights = 1,
                             country = rep(c("A","B"),each=4))
wells <- wells_actual %>% generate_image_wells(aquifer_unconfined)
```

Plot the aquifer and wells.

```{r set_simple_wells,echo=FALSE,cache=TRUE}
ggplot() +
  geom_segment(data=aquifer_unconfined$bounds,aes(x1,y1,xend=x2,yend=y2,color=bound_type)) +
  geom_abline(slope=0,intercept=500,linetype="dashed") +
  geom_point(data=wells_actual,aes(x,y,fill=country),shape=21) +
  coord_equal()
```

Get drawdown relationships using `get_drawdown_relationships()`. This function calculates the average drawdown at wells in each group defined by the column `group_column`. The average is taken as the weighted mean, determined by the `weights_column`. The weights were previously set equal for all wells so that the result here is a simple mean. The results show $\Phi_{ii}$ and $\Phi_{ij}$.

```{r drawdown_relationships,results='hide',cache=TRUE}
drawdown_relationships <- get_drawdown_relationships(wells, aquifer_unconfined, country, weights)
```

```{r print_drawdown_kable,echo=FALSE,cache=TRUE}
drawdown_relationships %>% 
  knitr::kable("html") #%>% kableExtra::kable_styling()
```

### Plot the head and flow

The hydrodynamics of the aquifer can be mapped by obtaining gridded heand flow using the `get_gridded_hydrodynamics()` function. The function takes as input the wells, aquifer, and grid dimensions for head and flow. It returns a `list` object with data.frames for head and flow, which can then be plotted.

```{r cache=TRUE}
gridded <- get_gridded_hydrodynamics(wells,aquifer_unconfined,c(20,20),c(8,8))
```

```{r echo=FALSE, warning=FALSE,cache=TRUE}
ggplot() +
  geom_raster(data=gridded$head,aes(x,y,fill=head_m)) +
  geom_segment(data=gridded$flow,aes(x,y,xend=x2,yend=y2),
               arrow = arrow(ends="last",type="closed",length=unit(1,"mm")),color="black") +
  geom_segment(data=aquifer_unconfined$bounds,aes(x1,y1,xend=x2,yend=y2,color=bound_type)) +
  geom_point(data=wells %>% filter(wID==orig_wID),aes(x,y),shape=21) +
  coord_equal()
```

## Validation

We need to validate the anem package for some simple use cases. In this validation we will consider:

1. hydraulic head in a confined aquifer
2. discharge potential in an unconfined aquifer
3. flow direction
4. behavior along boundaries 

### Hydrodynamics in a confined aquifer

To test the package in an unconfined aquifer, we define a confined aquifer with the following parameters and rectangular no-flow boundaries:
```{r}
aquifer <- define_aquifer(
  aquifer_type = "confined",
  Ksat=1e-4,
  z0=10,
  bounds=data.frame(bound_type=rep("NF",4),m=c(Inf,0,Inf,0),b=c(0,0,1000,1000))
)
```

We define a single pumping well in the center of the aquifer, with a pumping radius just less than the width of the aquifer.

```{r}
well <- define_wells(
  Q=-1,
  R=1200,
  diam=1,
  x=500,
  y=500
) %>% generate_image_wells(aquifer)
```

And finally, we select three locations for observation, including one at the well:

```{r}
loc <- tribble(~pID,~x,~y,
               1, 750, 500,
               2, 625, 750,
               3, 500, 500)
```

The well and its images and radii of influence, along with observation locations, look like this:

```{r confined_plot,fig.width=8,warning=FALSE,echo=FALSE,message=FALSE,cache=TRUE}
p_full <- ggplot() +
  geom_segment(data=aquifer$bounds,aes(x1,y1,xend=x2,yend=y2)) +
  geom_polygon(data=gen_circles(well),aes(x,y,group=id),alpha=0.25) +
  geom_point(data=well,aes(x,y,color=well_image)) +
  geom_point(data=loc,aes(x,y,shape="obs location")) +
  scale_shape_manual(values=4) +
  coord_equal()
p_aquifer <- p_full + coord_equal(xlim=c(0,1000),ylim=c(0,1000))
gridExtra::grid.arrange(p_full,p_aquifer,nrow=1)
```

The image wells are labeled "Image (+Q)", indicating they have the same sign as the "Actual" well. If the "Actual" well is negative, the images will also have negative pumping rates. The first point (pID=1) is within the radius of influence of four wells. We can manually calculate $h-h_0$ using the Thiem solution for the influence of each well

```{r loc_radii,echo=FALSE,cache=TRUE}
loc_radii <- loc %>% crossing(well %>% rename(xw=x,yw=y)) %>% 
  mutate(r=sqrt((xw-x)^2+(yw-y)^2),r=if_else(r<diam/2,diam/2,r)) %>%
  filter(r<R) %>%
  mutate(`h-h0`=-Q/(2*pi*aquifer$Ksat*aquifer$z0)*log(r/R))
loc_radii %>% filter(pID==1,r<R) %>% select(pID,wID,Q,well_image,r,`h-h0`) %>% 
  knitr::kable("html",1)
loc_radii_net <- loc_radii %>% group_by(pID) %>% summarize(net=sum(`h-h0`))
```

The sum of the $h-h_0$ column is `r round(loc_radii_net$net[loc_radii_net$pID==1],4)`. We can compare these results with those from `anem` and `get_potential_differential()`:

```{r cache=TRUE}
get_potential_differential(loc[loc$pID==1,],well,aquifer)
```

We can compare the same results for the second observation point: 

```{r loc_radii2,echo=FALSE,cache=TRUE}
loc_radii %>% filter(pID==2,r<R) %>% select(pID,wID,Q,well_image,r,`h-h0`) %>% 
  knitr::kable("html",1)
```

The sum of the $h-h_0$ column is `r round(loc_radii_net$net[loc_radii_net$pID==2],4)`.

```{r cache=TRUE}
get_potential_differential(loc[loc$pID==2,],well,aquifer)
```

And the results for the third observation point.

```{r loc_radii3,echo=FALSE,cache=TRUE}
loc_radii %>% 
  filter(pID==3,r<R) %>% mutate(r=format(r, scientific=F)) %>%
  select(pID,wID,Q,well_image,r,`h-h0`) %>% 
  knitr::kable("html",1,align=c('r','r','r','l','r','r'))
```

The sum of the $h-h_0$ column is `r round(loc_radii_net$net[loc_radii_net$pID==3],3)`.

```{r cache=TRUE}
get_potential_differential(loc[loc$pID==3,],well,aquifer)
```

In this last case, the observation location is within the radius of the well casing, which means that the effect of the co-located well is measured a distance of $r=diam/2=0.5$. In this case, the results are also valid.

### Hydrodynamics in an unconfined aquifer

Following the same analysis as above but redefining the aquifer as "unconfined", we further validate the package.

```{r cache=TRUE}
aquifer_uconfined <- define_aquifer(
  aquifer_type="unconfined",
  Ksat=1e-4,
  bounds=aquifer$bounds
)
```


The first point (pID=1) is within the radius of influence of four wells. We can manually calculate $h-h_0$ using the Thiem solution for the influence of each well

```{r loc_radii_unconf,echo=FALSE,cache=TRUE}
loc_radii <- loc %>% crossing(well %>% rename(xw=x,yw=y)) %>% 
  mutate(r=sqrt((xw-x)^2+(yw-y)^2),r=if_else(r<diam/2,diam/2,r)) %>%
  filter(r<R) %>%
  mutate(`phi-phi0`=-Q/(pi*aquifer_uconfined$Ksat)*log(r/R))
loc_radii %>% filter(pID==1,r<R) %>% select(pID,wID,Q,well_image,r,`phi-phi0`) %>% 
  knitr::kable("html",1)
loc_radii_net <- loc_radii %>% group_by(pID) %>% summarize(net=sum(`phi-phi0`))
```

The sum of the $\phi-\phi_0$ column is `r round(loc_radii_net$net[loc_radii_net$pID==1],3)`. We can compare these results with those from `anem` and `get_potential_differential()`:

```{r cache=TRUE}
get_potential_differential(loc[loc$pID==1,],well,aquifer_uconfined)
```

We can compare the same results for the second observation point: 

```{r loc_radii_unconf2,echo=FALSE,cache=TRUE}
loc_radii %>% filter(pID==2,r<R) %>% select(pID,wID,Q,well_image,r,`phi-phi0`) %>% 
  knitr::kable("html",1)
```

The sum of the $\phi-\phi_0$ column is `r round(loc_radii_net$net[loc_radii_net$pID==2],3)`.

```{r cache=TRUE}
get_potential_differential(loc[loc$pID==2,],well,aquifer_uconfined)
```

And the results for the third observation point.

```{r loc_radii_unconf3,echo=FALSE,cache=TRUE}
loc_radii %>% 
  filter(pID==3,r<R) %>% mutate(r=format(r, scientific=F)) %>%
  select(pID,wID,Q,well_image,r,`phi-phi0`) %>% 
  knitr::kable("html",1,align=c('r','r','r','l','r','r'))
```

The sum of the $\phi-\phi_0$ column is `r format(loc_radii_net$net[loc_radii_net$pID==3],scientific=F,nsmall=3)`.

```{r cache=TRUE}
get_potential_differential(loc[loc$pID==3,],well,aquifer_uconfined)
```

In this last case, the observation location is within the radius of the well casing, which means that the effect of the co-located well is measured a distance of $r=diam/2=0.5$. In this case, the results are also valid.

### Behavior along the boundaries

The function `get_bounds_behavior()` is a helper function to generate hydraulic properties at the boundaries. It obtains hydraulic head and the flow normal to the boundary. Normal flow is defined such that positive flow has some component in the x-direction (the y-direction depends on the normal vector for the boundary). The function `plot_bounds_behavior()` is a wrapper around `get_bounds_behavior()`, and it can be used to quickly compare the hydraulic head along the boundaries and flow across the boundaries under two scenarios: 

* no images (ie, homogeneous, uniform aquifer -- all well images removed)
* images (ie, aquifer with boundaries -- all well images intact)

```{r check_bounds,fig.width=6,fig.height=4,cache=TRUE}
bounds_behavior <- plot_bounds_behavior(wells,aquifer_unconfined)
gridExtra::grid.arrange(bounds_behavior$p_h,bounds_behavior$p_f,nrow=1)
```

The function `plot_bounds_behavior` also includes the raw data of head and flow used to create the above plots (`bounds_behavior$bounds_behavior`), as well as a summary of these values which includes mean head on each of the boundaries and mean flow as the average of the absolute value of flow normal to each boundary (`bounds_behavior$table`). To numerically check that the boundaries are working as expected, we can print `bounds_behavior$table`:

```{r echo=FALSE,cache=TRUE}
bounds_behavior$table %>% 
  knitr::kable("html") #%>% kableExtra::kable_styling()
```

## Use cases

